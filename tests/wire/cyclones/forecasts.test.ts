// This file was auto-generated by Fern from our API Definition.

import * as Earth from "../../../src/api/index";
import { EarthClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("Forecasts", () => {
    test("list (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new EarthClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                storm_id: "storm_id",
                storm_name: "storm_name",
                type: "type",
                category: 1,
                position: { latitude: 1.1, longitude: 1.1 },
                forecast_time: "2024-01-15T09:30:00Z",
                forecast_source_info: "forecast_source_info",
                forecast_last_updated: "2024-01-15T09:30:00Z",
            },
        ];
        server
            .mockEndpoint()
            .get("/cyclones/forecasts")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.cyclones.forecasts.list({
            time: "2024-01-15T09:30:00Z",
            min_storm_category: 1,
            model: "OFCL",
        });
        expect(response).toEqual([
            {
                storm_id: "storm_id",
                storm_name: "storm_name",
                type: "type",
                category: 1,
                position: {
                    latitude: 1.1,
                    longitude: 1.1,
                },
                forecast_time: "2024-01-15T09:30:00Z",
                forecast_source_info: "forecast_source_info",
                forecast_last_updated: "2024-01-15T09:30:00Z",
            },
        ]);
    });

    test("list (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new EarthClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/cyclones/forecasts")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.cyclones.forecasts.list();
        }).rejects.toThrow(Earth.UnprocessableEntityError);
    });

    test("track (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new EarthClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            bbox: [{ key: "value" }],
            type: "FeatureCollection",
            features: [
                {
                    type: "Feature",
                    geometry: { type: "GeometryCollection", geometries: [{ type: "LineString", coordinates: [[]] }] },
                    properties: { key: "value" },
                    id: 1,
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/cyclones/forecasts/storm_id/track")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.cyclones.forecasts.track("storm_id", {
            time: "2024-01-15T09:30:00Z",
            max_lead_time: "max_lead_time",
            model: "OFCL",
        });
        expect(response).toEqual({
            bbox: [
                {
                    key: "value",
                },
            ],
            type: "FeatureCollection",
            features: [
                {
                    type: "Feature",
                    geometry: {
                        type: "GeometryCollection",
                        geometries: [
                            {
                                type: "LineString",
                                coordinates: [[]],
                            },
                        ],
                    },
                    properties: {
                        key: "value",
                    },
                    id: 1,
                },
            ],
        });
    });

    test("track (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new EarthClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/cyclones/forecasts/storm_id/track")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.cyclones.forecasts.track("storm_id");
        }).rejects.toThrow(Earth.UnprocessableEntityError);
    });

    test("cone (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new EarthClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            bbox: [{ key: "value" }],
            type: "FeatureCollection",
            features: [
                {
                    type: "Feature",
                    geometry: { type: "GeometryCollection", geometries: [{ type: "LineString", coordinates: [[]] }] },
                    properties: { key: "value" },
                    id: 1,
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/cyclones/forecasts/storm_id/cone")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.cyclones.forecasts.cone("storm_id", {
            time: "2024-01-15T09:30:00Z",
            max_lead_time: "max_lead_time",
            smooth_cone: true,
            model: "OFCL",
        });
        expect(response).toEqual({
            bbox: [
                {
                    key: "value",
                },
            ],
            type: "FeatureCollection",
            features: [
                {
                    type: "Feature",
                    geometry: {
                        type: "GeometryCollection",
                        geometries: [
                            {
                                type: "LineString",
                                coordinates: [[]],
                            },
                        ],
                    },
                    properties: {
                        key: "value",
                    },
                    id: 1,
                },
            ],
        });
    });

    test("cone (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new EarthClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/cyclones/forecasts/storm_id/cone")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.cyclones.forecasts.cone("storm_id");
        }).rejects.toThrow(Earth.UnprocessableEntityError);
    });
});
